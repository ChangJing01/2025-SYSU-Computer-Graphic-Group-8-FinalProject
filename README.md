# **OpenGL实践**

## 用OpenGL搭建并渲染一个场景

&emsp;&emsp;2025中山大学计算机图形学第八小组期末项目：用OpenGL搭建并渲染一个场景<br>
&emsp;&emsp;在这个选题中，我们使用OpenGL搭建并渲染了一个微型图书馆场景，为了实现这一场景，我们实现了以下功能：
### 一、模型文件加载
&emsp;&emsp;使用Assimp库，在LearingOpenGL提供的model.h和mesh.h代码的基础上进行修改，实现了加载
gltf模型文件的功能。选择加载gltf模型文件是因为此模型与我们后面将实现的PBR光照模型能很好的契
合。<br>
其中，model.h 定义 Model 类，负责：<br>
&emsp;&emsp;1、调用 Assimp 加载整个模型文件（glTF/OBJ 等）；<br>
&emsp;&emsp;2、递归解析 Assimp 的aiNode节点树，将每个aiMesh转换为Mesh对象；<br>
&emsp;&emsp;3、加载模型关联的所有纹理（去重，避免重复加载同一纹理）；<br>
&emsp;&emsp;4、提供统一的Draw()方法，遍历所有 Mesh 完成整个模型的渲染。<br>
&emsp;&emsp;mesh.h 定义 Mesh 类，负责：<br>
&emsp;&emsp;1、存储单个网格的所有渲染数据（顶点、索引、纹理）；<br>
&emsp;&emsp;2、初始化 OpenGL 对象（VAO/VBO/EBO），将数据上传 GPU；<br>
&emsp;&emsp;3、提供 Draw() 方法，结合 Shader 完成单个网格的渲染。<br>
&emsp;&emsp;由于每一个gltf文件的设计形式不同，在设计model.h 和mesh.h时必须要考虑所有可能出现的情
况。有些gltf模型文件不存在金属度和粗糙度贴图甚至没有基础颜色贴图，其对应的金属度、粗糙度、基
础颜色因子设置在gltf文件中，因此在使用Model处理模型材质时必须要考虑加载的模型是使用的纹理贴
图还是纹理因子，亦或是两者都有用到。这同样影响着后续实施PBR光照模型的PBR片段着色器的设计。
为了更好的加载模型和渲染模型，我们构建了一个资源管理库。其可以储存项目中已经加载的模
型，可以避免渲染模型时模型的重复加载，减少内存的开销并增强程序运行时的性能
### 二、 PBR光照模型
&emsp;&emsp;PBR光照模型的实现重点在PBR片段着色器的设计上。实现PBR模型所用到的各类光学知识和用到的
数学计算公式统一参照LearingOpenGL教程中的内容。本次实现的PBR片段着色器实现了
LearingOpenGL教程中PBR介绍的所有功能，包括基于图像的光照(IBL）。此外，为了适配加载gltf模
型，PBR片段着色器对于纹理参数的设置进行了多项判断，保证纹理参数能够得到正确的设置。
### 三、实现基于图像的光照(IBL)
&emsp;&emsp;参照LearingOpenGL教程中给出的原理与计算公式以及提供的代码，实现了IBL。此功能可以将环境
立方体贴图 (Cubemap) 的每个像素视为光源，通过在渲染方程中直接使用它来有效地捕捉环境的全局光
照和氛围，使物体更好地融入其环境.
### 四、实现阴影效果
&emsp;&emsp; 参照LearingOpenGL教程中给出的原理与计算公式以及提供的代码，实现了点光源阴影。点光源阴
影实现的核心在于生成深度立方体贴图，对于点光源来说，这样的贴图一共要生成六个。这里选择使用
几何着色器实现一次渲染过程建立深度立方体贴图。在生成深度立方体贴图后，我们将这些立方体贴图
传递给我们的PBR光照片段着色器，用来计算对应的阴影因子。最后将这个阴影因子应用到我们实现颜
色计算的部分，便可以实现阴影了。同样，为了让实现的阴影更加的柔和与真实，使用到了PCF与动态
Bias。来解决阴影痤疮，漏光和锯齿化问题。
### 五、 实现将HDR立方体贴图作为天空盒
&emsp;&emsp;因为我们选择了使用PBR光照模型，因此相对于直接使用六面立方体天空盒贴图，实现将HDR场景
转化为立方体贴图作为天空盒更便于我们更真实的PBR光照模型的实现。首先我们将HDR场景使用
stb_image 存储到一张等距柱状投影图 中，随后运用LearingOpenGL提供的方法，将等距柱状投影图转
化为立方体贴图，最终实现天空盒的生成.
### 六、 实现视差遮蔽映射（POM）
&emsp;&emsp;传统法线贴图仅修改表面法线来模拟凹凸，而 POM 通过偏移纹理坐标让纹理 “贴合” 虚拟的高度地
形，视觉上更接近真实的几何凹凸（比如木纹的沟壑、地砖的缝隙）。在参考LearingOpenGL教程的基
础上，我们实现的POM兼顾了效果（32 层采样 + 插值）和性能（距离淡出 + 动态分层），并且可以兼
容PBR纹理中heightMap纹理图的输入.
### 七、优化camera.h
&emsp;&emsp;模拟一个虚拟相机。这个类封装了所有与相机相关的属性和功能：<br>
定义相机的位置和朝向：通过位置、前向向量、上向量等来定义相机在3D世界中的状态。<br>
控制相机移动：通过键盘输入（WASD、上下左右）来控制相机在场景中前后左右移动，以及上下移动。<br>
控制相机视角：通过鼠标移动来控制相机的水平（Yaw）和垂直（Pitch）旋转，从而改变观察方向。<br>
控制视野范围：通过鼠标滚轮来放大或缩小视野（类似变焦）。
生成视图矩阵：它根据相机的所有状态（位置、朝向等），生成一个视图矩阵（View Matrix）。这个矩
阵是OpenGL渲染管线中的一个关键矩阵，它告诉OpenGL如何将3D世界中的物体投影到2D屏幕上，从
而实现“从相机视角看世界”的效果
### 小组成员分工：
钟旺烜：模型文件加载；PBR光照模型；实现IBL；阴影效果；实现视差遮蔽映射（POM）；天空盒
HDR贴图。<br>
张誉方、钟思玥：基础框架构建（室内、室外）；天空盒设计；简易光源布置。<br>
张景翔：代码整理；动画建模；纹理精修（待后续）。<br>
柳亦霏：PPT制作；简易交互（摄像机优化）；动画建模；纹理精修（待后续）。<br>
曾壮：修复报错；纹理精修（待后续）.<br>










